#include "msec.h"
#include "Config.h"
#include "UDPCongestionControl.h"

using namespace fpnn;

//=================================================================//
//--             UDP Simple Congestion Controller                --//
//=================================================================//
//=================================================================//
//-- !!! The following parameters are not configurable (empirical parameters) !!!
//-- Source of magic number:
//-- Please refer ./test/udp-test/FactorCheckTest/UDPCCLoadIdx (generated by compiling cpp)
//=================================================================//
const float UDPSimpleCongestionController::unconfirmedIndexFactor = 0.5f;
const float UDPSimpleCongestionController::halfLoadThreshold = 1.8f;		//-- 1.6
const float UDPSimpleCongestionController::minLoadThreshold = 1.96f;		//-- 1.8
const int64_t UDPSimpleCongestionController::timeUnit = 500;

UDPSimpleCongestionController::UDPSimpleCongestionController()
{
	record.ts = 0;
	record.unconfirmedSize = 0;

	unconfirmedLoad.ts = 0;
	unconfirmedLoad.load = 0;
}

UDPSimpleCongestionController::~UDPSimpleCongestionController()
{
}

void UDPSimpleCongestionController::updateUnconfirmedIndex()
{
	float loadRate = record.unconfirmedSize * 1.0f / Config::UDP::_unconfiremed_package_limitation;
	float loadIndex = unconfirmedLoad.load * unconfirmedIndexFactor + loadRate;

	//-- Processing extremely simplified at present.
	unconfirmedLoad.ts = record.ts;
	unconfirmedLoad.load = loadIndex;
}

void UDPSimpleCongestionController::updateUnconfirmedSize(int64_t ts, size_t unconfirmedSize)
{
	if (ts - record.ts < timeUnit)
	{
		if (record.unconfirmedSize < unconfirmedSize)
			record.unconfirmedSize = unconfirmedSize;

		return;
	}
	else if (record.ts != 0)
	{
		updateUnconfirmedIndex();

		record.ts = ts;
		record.unconfirmedSize = unconfirmedSize;
	}
	else
	{
		record.ts = ts;
		record.unconfirmedSize = unconfirmedSize;
	}
}

//=================================================================//
//--              UDP Resend Interval Controller                 --//
//=================================================================//
//=================================================================//
//-- !!! The following parameters are not configurable (empirical parameters) !!!
//-- Source of magic number: Parameter matrix with thousands of cases and hundreds of hours of comparison test results.
//=================================================================//
const int64_t UDPResendIntervalController::defaultIntervalMS = 20;
const int64_t UDPResendIntervalController::lastDelaySustainMS = 2000;
const int64_t UDPResendIntervalController::lastDealyAttenuationMS = 20 * 1000;	//-- Include the time of using the original value.
const int64_t UDPResendIntervalController::maxIntervalMS = 150;
const int64_t UDPResendIntervalController::calculationPeriodMS = 250;
const float UDPResendIntervalController::factor = 1.2f;

UDPResendIntervalController::UDPResendIntervalController(): lastTs(0), lastDelay(defaultIntervalMS), minAvgDelay(defaultIntervalMS)
{
	record.count = 0;
	record.ts = 0;
	record.avgDelay = defaultIntervalMS;

	cache.total = 0;
	cache.count = 0;
}

void UDPResendIntervalController::updateDelay(int64_t ts, int64_t totalDelay, int count)
{
	if (count == 0)
		return;

	if (ts - record.ts < calculationPeriodMS)
	{
		int64_t total = record.count * record.avgDelay + totalDelay;
		record.count += count;
		record.avgDelay = total / record.count;
	}
	else
	{
		if (record.avgDelay < minAvgDelay)
			minAvgDelay = record.avgDelay;

		//-- Don't need additional checking. The related checking will be called in interval() function.
		//-- So, there is simple to deal with. 
		{
			lastTs = record.ts;
			lastDelay = record.avgDelay;
		}

		record.ts = ts;
		record.count = count;
		record.avgDelay = totalDelay / count;
	}
}

int64_t UDPResendIntervalController::interval(int64_t now)
{
	int64_t rev = minAvgDelay;
	int64_t timeDiff = now - lastTs;
	if (timeDiff <= lastDelaySustainMS)
	{
		if (lastDelay < maxIntervalMS)
			rev = lastDelay;
		else
			rev = maxIntervalMS;
	}
	else if (timeDiff < lastDealyAttenuationMS)
	{
		int64_t diff = lastDelay - minAvgDelay;
		int64_t refDelay = lastDelay - diff * timeDiff / lastDealyAttenuationMS;

		if (refDelay < maxIntervalMS)
			rev = refDelay;
		else
			rev = maxIntervalMS;
	}

	rev = (int64_t)(factor * rev);
	
	if (rev == 0)
		rev = 1;

	return rev;
}
